# Función para crear una tabla paramétrica
def crear_tabla_parametrica(documentos, nombre_tabla, LOG):
    LOG.log(f"Creando tabla paramétrica temporal: {nombre_tabla}")
    # Crear la tabla con valores únicos en la zona de datos de Procesos (ZDP)
    DB_SQL.execute(f"""
        CREATE TABLE {nombre_tabla} (documento BIGINT)
        STORED AS PARQUET TBLPROPERTIES ('external.table.purge'='true')
    """)
    # Insertar los documentos en la tabla paramétrica
    valores_insert = ",".join(f"({int(doc)})" for doc in documentos)
    DB_SQL.execute(f"""
        INSERT INTO {nombre_tabla} (documento) VALUES {valores_insert}
    """)
    DB_SQL.execute(f"COMPUTE STATS {nombre_tabla}")

# Crear tabla paramétrica y reemplazar IN por JOIN en la función principal
def get_pgc_plan_comercial_cliente(docClientes, year_ini, LOG):
    year_ini = int(year_ini)
    year_fin = int(datetime.now().year)
    nombre_tabla_parametrica = "proceso.tbl_parametrica_docs"
    
    # Crear tabla paramétrica para los documentos
    crear_tabla_parametrica(docClientes, nombre_tabla_parametrica, LOG)

    df = pd.DataFrame()
    for year in range(year_ini, year_fin + 1):
        LOG.log(f"Consultando año: {year}")
        sql = f"""
            SELECT cod_ase_vta_dir AS CODASE, CAST(num_doc_vta_dir AS BIGINT) AS DOC_ASESOR,
                   nombre_ase_vta_dir AS NOMBRE_ASESOR, nivel_ase_vta_dir AS CARGO_ASESOR,
                   CAST(num_doc_cli AS BIGINT) AS DOC_CLIENTE, T1.nombre_cli AS NOMBRE_CLIENTE,
                   segmento AS SEGMENTO, cod_of_apert_vta_dir AS COD_OFI_APERTU, of_apert_vta_dir AS OFI_APERTU,
                   cod_of_vta_dir, of_vta_dir, TRIM(APLICACION) AS APLICACION, PLAN, nombre_prod AS NOMBRE_PRODUCTO,
                   CAST(producto AS STRING) AS NRO_PRODUCTO, monto AS VALOR, f_originacion AS FECHA_ACTIV,
                   PLAZO, region_vend_vta_dir, zona_apert_vta_dir, zona_vend_vta_dir, cod_ase_vta_ref AS COD_ASESOR_VTA_REFERIDO,
                   num_doc_vta_ref AS DOC_ASESOR_VTA_REFERIDO, nombre_ase_vta_ref AS NOMBRE_ASESOR_VTA_REFERIDO,
                   ciudad_vta_ref AS CIUDAD_VTA_REFERIDO, compania AS EMPRESA, f_nacim_cli AS FECHA_NACIMIENTO_CLIENTE,
                   ciudad_nacim AS CIUDAD_NACIMIENTO_CLIENTE, edad_cli AS EDAD_CLIENTE, f_vinc AS FECHA_VINCULACION_CLIENTE,
                   tipo_dirp AS TIPO_DIRECCION_CLIENTE, dir_p AS DIRECCION_CLIENTE, nombre_ciudad_dirp AS CIUDAD_DIRECCION_CLIENTE,
                   email1 AS CORREO_CLIENTE, celular1 AS CELULAR_CLIENTE, tel1_valido AS TELEFONO_CLIENTE,
                   dir_1 AS DIRECCION_2_CLIENTE, nombre_ciudad_dir1 AS CIUDAD_DIRECCION_2_CLIENTE,
                   cel1_contactabilidad AS CEL_CONTACTABILIDAD, email1_contactabilidad AS CORREO_CONTACTABILIDAD
            FROM resultados_cdex_medicion_com.rep_ventas_productos AS T1
            JOIN {nombre_tabla_parametrica} AS TP ON T1.num_doc_vta_dir = TP.documento
            LEFT JOIN RESULTADOS_VSPC_CLIENTES.MASTER_CUSTOMER_DATA AS T2 ON T1.llave_nombre = T2.llave_sistema
            WHERE T1.year = {year} AND {DB_LZ.get_ultima_inges_alias('master_customer_data','T2')}
            AND T1.f_originacion >= 2020
        """
        df = df.append(DB_LZ.sql_get(sql))

    df.columns = map(str.upper, df.columns)
    df = df.drop_duplicates(['CODASE', 'DOC_ASESOR', 'DOC_CLIENTE', 'NOMBRE_CLIENTE', 'OFI_APERTU', 
                             'PLAN', 'NOMBRE_PRODUCTO', 'NRO_PRODUCTO', 'VALOR', 'FECHA_ACTIV', 
                             'COD_ASESOR_VTA_REFERIDO', 'DOC_ASESOR_VTA_REFERIDO'])
    docClientes = df["DOC_CLIENTE"].values
    docConsulta = " ".join(map(str, docClientes))
    
    # Obtener cartera castigada y vencida, y combinar datos
    df_cartera = get_cartera_castigada(docConsulta, LOG, nombre_tabla_parametrica)
    df_vencida = get_cartera_vencida(docConsulta, LOG, nombre_tabla_parametrica)
    df = df.merge(df_cartera, on="NRO_PRODUCTO", how="left").merge(df_vencida, on="NRO_PRODUCTO", how="left")

    if not df.empty:
        df['DESC_PRODUCTO'] = df['DESC_PRODUCTO'].fillna('')
        df['OBLIGACION'] = df.apply(lambda x: x.OBLIGACION[-4:] if x.DESC_PRODUCTO.strip() == 'TARJETA DE CREDITO' else x.OBLIGACION, axis=1)
    return df

# Modificar las funciones de cartera para que usen la tabla paramétrica en lugar de IN
def get_cartera_castigada(documentos, LOG, nombre_tabla_parametrica):
    LOG.log("Consultar cartera castigada")
    sql = f"""
        SELECT TRIM(AMNOAC) AS NRO_PRODUCTO, AMDTCA AS FECHA_CASTIGO, AMAMTO AS VALOR_TOTAL_CASTIGO
        FROM VISIONR.AMBAL AS T1
        INNER JOIN VISIONR.CXREF AS T2 ON AMCDAP = CXCDAP AND AMNOAC = CXNOAC
        INNER JOIN VISIONR.CNAME AS T3 ON CNNAMK = CXNAMK
        JOIN {nombre_tabla_parametrica} AS TP ON CNNOSS = TP.documento
        ORDER BY CNNOSS, AMNOAC
    """
    return DB_AS400.sql_get(sql, 'NACIONAL')

def get_cartera_vencida(documentos, LOG, nombre_tabla_parametrica):
    LOG.log("Consultar cartera vencida")
    year, corte = get_latest_cutoff()
    
    sql_vencida = f"""
        SELECT CAST(CAST(obl341 AS BIGINT) AS STRING) AS NRO_PRODUCTO, SUM(SK) AS SALDO_CAPITAL,
               SUM(cv1) AS CARTERA_VENCIDA, PCONS AS DESC_PRODUCTO, fdesem AS FECHA_DESEMBOLSO
        FROM resultados_riesgos.ceniegarc_lz
        JOIN {nombre_tabla_parametrica} AS TP ON id = TP.documento
        WHERE YEAR = {year} AND corte = {corte}
        GROUP BY ID, OBL341, APL, CORTE, sgto, fdesem, vdesem, apl, altmora, name, pcons, segdesc
    """
    return DB_LZ.sql_get(sql_vencida)
